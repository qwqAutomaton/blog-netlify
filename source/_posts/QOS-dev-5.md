---
title: QOS 开发 5
date: 2024-08-23 09:43:26
tags:
  - 操作系统
  - 汇编
description: 补充一下之前进入保护模式的一些细节 qwq 以及怎么查询机子的内存容量
---

# QOS 开发日记 5: 流水线和内存

## 流水线

进入保护模式之前需要先 `jmp` 一次还记得嘛 qwq

```x86asm
jmp dword SEL_CODE:pe_start
```

这里的 `dword` 应该比较好理解，意思是后面的这个地址的大小是双字（$4\texttt B = 32\texttt{bit}$）。后面地址这里也应该比较清楚：由于前面已经开启了保护模式（`CR0` 的 `PE` 设置成 1 了），所以需要用选择子找到代码段的位置（`SEL_CODE`），然后再跳到对应的 label. 可是为什么要这么做呢？

考虑底层的一些东西。众所周知，CPU 为了加快运行效率，采用了流水线执行：

![3 级流水线的例子](pipeline.png)

那么这个就是流水线了。

然而有些指令可能执行时间很长，比如

```x86asm
mov eax, [0x1111] ; 从内存 0x1111 取值
add ecx, ebx ; 加法
```

取内存的指令执行时间很长，可能要好几个周期；然而它和后面做加法的指令没有逻辑 / 数据上的冲突。因此我们可以把加法指令提出来先做，也就是**乱序执行**。

虽然 x86 最初支持的指令集是 CISC（复杂指令集），但是发展到现在，它的内核已经变成 RISC（精简指令集）了，把大的操作分成了很多小的操作。而那些小的操作基本上逻辑关联不大，因此可以利用乱序执行优化效率。

不过既然要做这种乱序执行，肯定要先计算出到底是什么个「乱」法（这个活是编译器 / 汇编器在干的）；然后就需要把这些顺序加入到流水线里进行真正的执行了。

还有一个就是分支预测。也就是 CPU 会预测各种 `jmp` 指令跳转的概率，并把（看起来）概率更大的那个预先加载到流水线里面。可以类比 C++ 里面的

```cpp
if (__builtin_expect(!!(/* Condition */), 1))
    { /* Expected to be more possible */ }
else { /* Expected to be less possible */ }
```

那么缺点就是如果遇到了和预测不匹配的地方就要把之前预测的流水线清空，开销比较大。不过其实也不会出现什么致命性的问题就是了。

然而在实模式下的指令和保护模式下的指令并不相同，直接执行流水线里面的值很可能会有错误。因此就要通过一个远跳（far jump）清空流水线，也就是代码里的

```x86asm
jmp     dword       SEL_CODE : pe_start
;       ^~~~~       ^~~~~~~~   ^~~~~~~~
;   表示地址是 32 位  选择子（段）    标记
; jmp <段>:<地址> 就是远跳啦
```

那么清空了实模式下的流水线，接下来就正式进入保护模式了（彻底抹除了实模式的痕迹 qaq）。

## 内存查询

那么如何查询具体的内存大小？咕咕
